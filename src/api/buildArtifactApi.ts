/**
 * Bitrise API
 * Official REST API for Bitrise.io
 *
 * The version of the OpenAPI document: 0.1
 * Contact: letsconnect@bitrise.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { ServiceStandardErrorRespModel } from '../model/serviceStandardErrorRespModel';
import { V0ArtifactDeleteResponseModel } from '../model/v0ArtifactDeleteResponseModel';
import { V0ArtifactListResponseModel } from '../model/v0ArtifactListResponseModel';
import { V0ArtifactShowResponseModel } from '../model/v0ArtifactShowResponseModel';
import { V0ArtifactUpdateParams } from '../model/v0ArtifactUpdateParams';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.bitrise.io/v0.1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum BuildArtifactApiApiKeys {
    AddonAuthToken,
    PersonalAccessToken,
}

export class BuildArtifactApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AddonAuthToken': new ApiKeyAuth('header', 'Bitrise-Addon-Auth-Token'),
        'PersonalAccessToken': new ApiKeyAuth('header', 'Authorization'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: BuildArtifactApiApiKeys, value: string) {
        (this.authentications as any)[BuildArtifactApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * Delete a build artifact of an app\'s build. The required parameters are app slug, build slug and artifact slug. You can fetch the build artifact slug if you first list all build artifacts of an app with the [/apps/](https://api-docs.bitrise.io/#/build-artifact/artifact-list) endpoint.
     * @summary Delete a build artifact
     * @param appSlug App slug
     * @param buildSlug Build slug
     * @param artifactSlug Artifact slug
     */
    public async artifactDelete (appSlug: string, buildSlug: string, artifactSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: V0ArtifactDeleteResponseModel;  }> {
        const localVarPath = this.basePath + '/apps/{app-slug}/builds/{build-slug}/artifacts/{artifact-slug}'
            .replace('{' + 'app-slug' + '}', encodeURIComponent(String(appSlug)))
            .replace('{' + 'build-slug' + '}', encodeURIComponent(String(buildSlug)))
            .replace('{' + 'artifact-slug' + '}', encodeURIComponent(String(artifactSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'appSlug' is not null or undefined
        if (appSlug === null || appSlug === undefined) {
            throw new Error('Required parameter appSlug was null or undefined when calling artifactDelete.');
        }

        // verify required parameter 'buildSlug' is not null or undefined
        if (buildSlug === null || buildSlug === undefined) {
            throw new Error('Required parameter buildSlug was null or undefined when calling artifactDelete.');
        }

        // verify required parameter 'artifactSlug' is not null or undefined
        if (artifactSlug === null || artifactSlug === undefined) {
            throw new Error('Required parameter artifactSlug was null or undefined when calling artifactDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.PersonalAccessToken.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.PersonalAccessToken.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V0ArtifactDeleteResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "V0ArtifactDeleteResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * List all build artifacts that have been generated for an app\'s build. You can use the created build artifact slugs from the response output to retrieve data of a specific build artifact with the [GET/apps/](https://api-docs.bitrise.io/#/build-artifact/artifact-show) endpoint or update a build artifact with the [PATCH/apps](https://api-docs.bitrise.io/#/build-artifact/artifact-update) endpoint.
     * @summary Get a list of all build artifacts
     * @param appSlug App slug
     * @param buildSlug Build slug
     * @param next Slug of the first build artifact in the response
     * @param limit Max number of build artifacts per page is 50.
     */
    public async artifactList (appSlug: string, buildSlug: string, next?: string, limit?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: V0ArtifactListResponseModel;  }> {
        const localVarPath = this.basePath + '/apps/{app-slug}/builds/{build-slug}/artifacts'
            .replace('{' + 'app-slug' + '}', encodeURIComponent(String(appSlug)))
            .replace('{' + 'build-slug' + '}', encodeURIComponent(String(buildSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'appSlug' is not null or undefined
        if (appSlug === null || appSlug === undefined) {
            throw new Error('Required parameter appSlug was null or undefined when calling artifactList.');
        }

        // verify required parameter 'buildSlug' is not null or undefined
        if (buildSlug === null || buildSlug === undefined) {
            throw new Error('Required parameter buildSlug was null or undefined when calling artifactList.');
        }

        if (next !== undefined) {
            localVarQueryParameters['next'] = ObjectSerializer.serialize(next, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AddonAuthToken.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AddonAuthToken.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.PersonalAccessToken.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.PersonalAccessToken.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V0ArtifactListResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "V0ArtifactListResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Retrieve data of a specific build artifact. The response output contains a time-limited download url (expires in 10 minutes) and a public install page URL. You can view the build artifact with both URLs, but the public install page url will not work unless you [enable it](https://devcenter.bitrise.io/tutorials/deploy/bitrise-app-deployment/#enabling-public-page-for-the-app).
     * @summary Get a specific build artifact
     * @param appSlug App slug
     * @param buildSlug Build slug
     * @param artifactSlug Artifact slug
     */
    public async artifactShow (appSlug: string, buildSlug: string, artifactSlug: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: V0ArtifactShowResponseModel;  }> {
        const localVarPath = this.basePath + '/apps/{app-slug}/builds/{build-slug}/artifacts/{artifact-slug}'
            .replace('{' + 'app-slug' + '}', encodeURIComponent(String(appSlug)))
            .replace('{' + 'build-slug' + '}', encodeURIComponent(String(buildSlug)))
            .replace('{' + 'artifact-slug' + '}', encodeURIComponent(String(artifactSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'appSlug' is not null or undefined
        if (appSlug === null || appSlug === undefined) {
            throw new Error('Required parameter appSlug was null or undefined when calling artifactShow.');
        }

        // verify required parameter 'buildSlug' is not null or undefined
        if (buildSlug === null || buildSlug === undefined) {
            throw new Error('Required parameter buildSlug was null or undefined when calling artifactShow.');
        }

        // verify required parameter 'artifactSlug' is not null or undefined
        if (artifactSlug === null || artifactSlug === undefined) {
            throw new Error('Required parameter artifactSlug was null or undefined when calling artifactShow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AddonAuthToken.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AddonAuthToken.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.PersonalAccessToken.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.PersonalAccessToken.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V0ArtifactShowResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "V0ArtifactShowResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * Update the `is_public_page_enabled` attribute of your app\'s build. The required parameters are app slug, build slug and artifact slug. You can fetch the build artifact slug if you first list all build artifacts of an app with the [GET /apps/](https://api-docs.bitrise.io/#/build-artifact/artifact-list) endpoint.
     * @summary Update a build artifact
     * @param appSlug App slug
     * @param buildSlug Build slug
     * @param artifactSlug Artifact slug
     * @param artifactParams Artifact parameters
     */
    public async artifactUpdate (appSlug: string, buildSlug: string, artifactSlug: string, artifactParams: V0ArtifactUpdateParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: V0ArtifactShowResponseModel;  }> {
        const localVarPath = this.basePath + '/apps/{app-slug}/builds/{build-slug}/artifacts/{artifact-slug}'
            .replace('{' + 'app-slug' + '}', encodeURIComponent(String(appSlug)))
            .replace('{' + 'build-slug' + '}', encodeURIComponent(String(buildSlug)))
            .replace('{' + 'artifact-slug' + '}', encodeURIComponent(String(artifactSlug)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'appSlug' is not null or undefined
        if (appSlug === null || appSlug === undefined) {
            throw new Error('Required parameter appSlug was null or undefined when calling artifactUpdate.');
        }

        // verify required parameter 'buildSlug' is not null or undefined
        if (buildSlug === null || buildSlug === undefined) {
            throw new Error('Required parameter buildSlug was null or undefined when calling artifactUpdate.');
        }

        // verify required parameter 'artifactSlug' is not null or undefined
        if (artifactSlug === null || artifactSlug === undefined) {
            throw new Error('Required parameter artifactSlug was null or undefined when calling artifactUpdate.');
        }

        // verify required parameter 'artifactParams' is not null or undefined
        if (artifactParams === null || artifactParams === undefined) {
            throw new Error('Required parameter artifactParams was null or undefined when calling artifactUpdate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(artifactParams, "V0ArtifactUpdateParams")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.PersonalAccessToken.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.PersonalAccessToken.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V0ArtifactShowResponseModel;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "V0ArtifactShowResponseModel");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
